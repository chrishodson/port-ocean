AWSTemplateFormatVersion: '2010-09-09'
Description: >-
  AWS Serverless stack for Port integration. Creates an EventBridge rule that routes
  AWS events to an SQS queue and a Lambda function that processes the queue and
  forwards enriched events to Port via a single ingest webhook.

Parameters:
  QueueName:
    Type: String
    Default: port-aws-events-queue
    Description: Name of the SQS queue
  LambdaFunctionName:
    Type: String
    Default: port-aws-event-processor
  LambdaRuntime:
    Type: String
    Default: python3.11
  Handler:
    Type: String
    Default: index.lambda_handler
  PortWebhookUrl:
    Type: String
    Description: The Port ingest webhook URL that the Lambda will POST to (include schema 'https://')
  EventBridgePattern:
    Type: String
    Default: |
      {
        "$or": [
          {
            "source": ["aws.ecs"],
            "detail-type": ["ECS Container Instance State Change"]
          },
          {
            "source": ["aws.ec2"],
            "detail-type": ["EC2 Instance State-change Notification"],
            "detail": {
              "state": ["running", "terminated", "stopped"]
            }
          },
          {
            "source": ["aws.s3"],
            "detail-type": ["AWS Service Event via CloudTrail"],
            "detail": {
              "eventSource": ["s3.amazonaws.com"]
            }
          }
        ]
      }
    Description: EventBridge event pattern filter (JSON format)

Resources:
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${QueueName}-dlq"
      MessageRetentionPeriod: 1209600

  EventsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Ref QueueName
      MessageRetentionPeriod: 3600
      VisibilityTimeout: 60
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt DeadLetterQueue.Arn
        maxReceiveCount: 3

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${LambdaFunctionName}-execution-role-${AWS::StackName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SqsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:ChangeMessageVisibility
                  - sqs:GetQueueUrl
                  - sqs:GetQueueAttributes
                Resource: !GetAtt EventsQueue.Arn

  PortEventsProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref LambdaFunctionName
      Runtime: !Ref LambdaRuntime
      Handler: !Ref Handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          PORT_WEBHOOK_URL: !Ref PortWebhookUrl
      Code:
        ZipFile: |
          import json
          import os
          import logging
          from urllib import request, error

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          PORT_WEBHOOK = os.environ.get('PORT_WEBHOOK_URL')

          def post_to_port(body_bytes, headers):
            try:
              req = request.Request(PORT_WEBHOOK, data=body_bytes, headers=headers, method='POST')
              with request.urlopen(req, timeout=10) as resp:
                return resp.getcode(), resp.read().decode('utf-8')
            except error.HTTPError as e:
              logger.error('HTTP error %d posting to Port: %s', e.code, e.read().decode('utf-8'))
              raise
            except error.URLError as e:
              logger.error('URL error posting to Port: %s', e.reason)
              raise

          def lambda_handler(event, context):
            logger.info('Received event with %d records', len(event.get('Records', [])))
            failed_records = []
            for idx, rec in enumerate(event.get('Records', [])):
              body = rec.get('body')
              if not body:
                logger.warning('Record %d has no body, skipping', idx)
                continue
              try:
                payload = json.loads(body)
              except Exception:
                logger.exception('Record %d: Failed to parse event body', idx)
                failed_records.append(rec.get('messageId'))
                continue

              body_bytes = json.dumps(payload).encode('utf-8')
              headers = {'Content-Type': 'application/json'}
              try:
                status, resp_text = post_to_port(body_bytes, headers)
                logger.info('Record %d: Posted event to Port, status=%s, source=%s', idx, status, payload.get('source'))
              except Exception:
                logger.exception('Record %d: Error posting to Port', idx)
                failed_records.append(rec.get('messageId'))
            
            if failed_records:
              logger.warning('Failed to process %d records: %s', len(failed_records), failed_records)
            return {'statusCode': 200, 'processed': len(event.get('Records', [])) - len(failed_records)}

  EventBridgeToSqsRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "Route selected AWS events to SQS queue for Port processing"
      EventPattern: !Ref EventBridgePattern
      State: ENABLED
      Targets:
        - Arn: !GetAtt EventsQueue.Arn
          Id: SqsTarget
          RetryPolicy:
            MaximumEventAge: 3600
            MaximumRetryAttempts: 2
          DeadLetterConfig:
            Arn: !GetAtt DeadLetterQueue.Arn

  SqsQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref EventsQueue
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: "sqs:SendMessage"
            Resource: !GetAtt EventsQueue.Arn
            Condition:
              ArnEquals:
                aws:SourceArn: !GetAtt EventBridgeToSqsRule.Arn

  EventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 10
      EventSourceArn: !GetAtt EventsQueue.Arn
      FunctionName: !GetAtt PortEventsProcessorFunction.Arn
      Enabled: True

Outputs:
  QueueUrl:
    Description: URL for the SQS queue
    Value: !Ref EventsQueue
    Export:
      Name: !Sub "${AWS::StackName}-QueueUrl"
  QueueArn:
    Description: ARN of the SQS queue
    Value: !GetAtt EventsQueue.Arn
    Export:
      Name: !Sub "${AWS::StackName}-QueueArn"
  DeadLetterQueueUrl:
    Description: URL for the dead-letter queue (failed messages)
    Value: !Ref DeadLetterQueue
    Export:
      Name: !Sub "${AWS::StackName}-DLQUrl"
  LambdaName:
    Description: Lambda function name
    Value: !Ref PortEventsProcessorFunction
    Export:
      Name: !Sub "${AWS::StackName}-LambdaName"
  LambdaArn:
    Description: ARN of the Lambda function
    Value: !GetAtt PortEventsProcessorFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-LambdaArn"
  EventBridgeRuleArn:
    Description: ARN of the EventBridge rule
    Value: !GetAtt EventBridgeToSqsRule.Arn
    Export:
      Name: !Sub "${AWS::StackName}-RuleArn"
